# Пояснительная записка к л\р №1

## Требования к инструментам для выполнения л\р:
* UNIX-окружение, например ОС Debian 9.5.
* Установленный пакет python-minimal (Python 2)
* программа process-run.py

## Описание process-run.py

Программа process-run.py позволяет вам эмулировать выполнение процессов и операций ввода-вывода, просматривать их состояние
и изменение состояния в процессе работы на CPU.

В рамках данной л\р процессы могут находиться в следующих состояниях:

* RUNNING - Процесс использует CPU в данный момент
* READY   - Процесс готов к использованию CPU, но планировщик не дает процессорного времени
* WAITING - Процесс ожидает окончания I/O
* DONE    - Процесс завершил свою работу

## Запуск программы

Для запуска программы следует использовать следующую команду:
```
prompt> ./process-run.py -h
```
В случае, если это не сработает, можно указать интерпретатор напрямую:
```
prompt> python process-run.py -h
```

## Опции (ключи)


**-h, --help**            вывести подсказку и завершить работу

**-l PROCESS_LIST, --processlist=PROCESS_LIST**

Cписок процессов, разделенных запятой в формате X1:Y1,X2:Y2,...

X - число инструкций, которое должен выполнить процесс,

Y - шанс (от 0 до 100) того, что инструкция будет использовать CPU,
в противном случае выполнить операцию I/O.

**-s SEED, --seed=SEED  the random seed**

Ключ позволяет создать случайный набор разнообразных задач

**-L IO_LENGTH, --iolength=IO_LENGTH**

Ключ позволяет задать время выполнения I/O (по-умолчанию 5 тактов)

**-S PROCESS_SWITCH_BEHAVIOR, --switch=PROCESS_SWITCH_BEHAVIOR**

Когда переключаться между процессами: SWITCH_ON_IO, SWITCH_ON_END
```
    - SWITCH_ON_IO, система будет переключаться на другой процесс, когда первый
                     вызывает I/O
    - SWITCH_ON_END, система будет переключаться на другой процесс, только
                     когда первый процесс завершился
```

**-I IO_DONE_BEHAVIOR, --iodone=IO_DONE_BEHAVIOR**

Ключ задает поведение после окончания I/O: IO_RUN_LATER, IO_RUN_IMMEDIATE
```
    - IO_RUN_IMMEDIATE: Переключиться на этот процесс немедленно
    - IO_RUN_LATER: Переключиться на процесс, когда планировщик выделит ему время
                    (в зависимости от поведения планировщика)
```

Наиболее важной опцией является PROCESS_LIST (указываемая с помощью флага -l) которой можно задать параметры эмулируемых программ (процессов). Каждый процесс состоит из инструкций, каждая из которых может сделать одно
из двух:
* Использовать CPU
* Запросить операцию ввода-вывода (и дождаться ее исполнения)

Когда программа использует CPU (без вызова I/O), она переключается только между двумя состояниями - RUNNING (запущена на CPU) и READY
(готова к работе).

## Примеры работы программы с различными ключами

### Пример 1:

Вывод программы, эмулирующей один процесс, использующий CPU:

```
prompt> ./process-run.py -l 5:100 

Process 0
  cpu
  cpu
  cpu
  cpu
  cpu
```
Особенности вывода программы при запуске:

Система будет переключаться между процессами, когда текущий процесс ЗАВЕРШИЛСЯ или ЗАПРОСИЛ I/O. После выполнения I/O процесс, запросивший I/O продолжит работу ПОЗДНЕЕ, т.е. когда наступит его очередь.

В данном примере был указан ключ -l с параметром 5:100, что означает, что будет проэмулирован один процесс, состоящий из 5 инструкций и с 100% шансом того, что инструкция будет использовать CPU.

Для лучшего понимания происходящего, операции можно представить в такой форме:

```
prompt> ./process-run.py -l 5:100

Time     PID: 0        CPU        IOs
  1     RUN:cpu          1
  2     RUN:cpu          1
  3     RUN:cpu          1
  4     RUN:cpu          1
  5     RUN:cpu          1
```

### Пример 2:

Вывод программы, эмулирующей два процесса, использующих CPU:

```
prompt> ./process-run.py -l 5:100,5:100

Process 0
  cpu
  cpu
  cpu
  cpu
  cpu

Process 1
  cpu
  cpu
  cpu
  cpu
  cpu
```

Особенности вывода программы при запуске:

Планировщик будет передавать процессорное время, когда процесс ЗАВЕРШИЛСЯ или ЗАПРОСИЛ I/O. После выполнения I/O процесс, запросивший I/O продолжит работу ПОЗДНЕЕ, т.е. когда наступит его очередь.

В этом случае два разных процесса запущены и оба будут использовать CPU.

Для лучшего понимания происходящего, операции можно представить в такой форме:

```
Time     PID: 0     PID: 1        CPU        IOs
  1     RUN:cpu      READY          1
  2     RUN:cpu      READY          1
  3     RUN:cpu      READY          1
  4     RUN:cpu      READY          1
  5     RUN:cpu      READY          1
  6        DONE    RUN:cpu          1
  7        DONE    RUN:cpu          1
  8        DONE    RUN:cpu          1
  9        DONE    RUN:cpu          1
 10        DONE    RUN:cpu          1
```

В представленном выводе видно, что первый процесс с PID=0 запущен, тогда как процесс PID=1 находится в состоянии READY, ожидая завершения PID=1. Когда PID=0 завершается, он переходит в состояние DONE, в то время как процесс PID=1 запущен и работает. Когда PID-1 завершает работу, отслеживание и вывод прекращаются.

### Пример 3:

Вывод программы, эмулирующей один процесс, вызывающий I/O. Здесь также указан флаг -L который задает время выполнения процесса I/O.

```
prompt> ./process-run.py -l 3:0 -L 5

Process 0
  io-start
  io-start
  io-start
```

Особенности вывода программы при запуске:

Планировщик будет передавать процессорное время, когда процесс ЗАВЕРШИЛСЯ или ЗАПРОСИЛ I/O. После выполнения I/O процесс, запросивший I/O продолжит работу ПОЗДНЕЕ, т.е. когда наступит его очередь.

После завершения I/O процесс должен перейти в одно из 3-х состояний: READY, RUN:cpu, RUN:io-start, DONE. Состояния READY и DONE не утилизируют никакое оборудование, но при этом тратят один такт процессора.

Для лучшего понимания происходящего, операции можно представить в такой форме:

```
Time     PID: 0        CPU        IOs
  1  RUN:io-start       1
  2     WAITING                     1
  3     WAITING                     1
  4     WAITING                     1
  5     WAITING                     1
  6* RUN:io-start       1
  7     WAITING                     1
  8     WAITING                     1
  9     WAITING                     1
 10     WAITING                     1
 11* RUN:io-start       1
 12     WAITING                     1
 13     WAITING                     1
 14     WAITING                     1
 15     WAITING                     1
 16*       DONE
```

Как видно из таблицы выше, программа всего лишь запрашивает 3 операции I/O. Когда запрашивается каждая операция I/O, процесс переходит в состояние WAITING, и до тех пор, пока операция I/O не завершится, CPU находится в состонии ожидания.

## Подсчет статистики использования устройств:

```
Stats: Total Time 16
Stats: CPU Busy 3 (18.75%)
Stats: IO Busy  12 (75.00%)
```

Из статистики видно, что прошло 16 тактов процессора, но из всех тактов CPU был занят менее 20% времени. Напротив, устройство ввода-вывода
было довольно-таки занято выполнением операций. В идеале необходимо планировать работу процессов таким образом, чтобы устройства были использованы равномерно и постоянно, поскольку это наиболее производительное использование ресурсов.

## Задание

1. Запустите программу process-run.py со следующими флагами: **-l 5:100,5:100**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: какой процент времени от работы программы использовался процессор? Почему?
2. Запустите программу process-run.py со следующими флагами: **-l 4:100,1:0**. Эти флаги зададут 4 такта для одного процесса (полностью использующего CPU) и один такт для процесса, который вызовет I/O и подождет его завершения. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: сколько тактов займет завершение обоих процессов.
3. Поменяйте порядок параметров для ключа -l (**-l 1:0,4:100**)и запустите программу. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: повлиял ли порядок запуска процессов на количество тактов? Почему?
4. Поэкспериментируйте с флагом -S. Этот флаг определяет реакцию системы в момент вызова I/O. С флагом, выставленным в значение **SWITCH_ON_END** система не будет переключаться на другой процесс пока первый не закончит с I/O. Запустите программу с ключами **1:0,4:100 -S SWITCH_ON_END**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: Как изменится картина по сравнению с предыдущими запусками?
5. Запустите программу, но на этот раз поменяйте поведение планировщика так, чтобы он переключался на другой процесс, пока первый ожидает I/O. Запустите программу с ключами **-l 1:0,4:100 -S SWITCH_ON_IO**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: Как поведет себя программа в этом случае?
6. Одно из немаловажных поведений - принятие решение о том, что делать после того как процесс I/O завершится. С ключом **-I IO_RUN_LATER** после завершения I/O процесс, который вызвал I/O не обязательно продолжит свою работу, напротив, процесс который утилизировал CPU в данный момент продолжит его использование. А затем следующие ожидающие процессы. Запустите программу с ключами **-l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: Эффективно ли используются ресурсы? Почему?
7. Запустите программу с ключами **-l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: Эффективно ли используются ресурсы? Как изменилось поведение планировщика? Почему передача управления процессу, только что завершившему процесс I/O может быть хорошей идеей?
8. Запустите случайно сгенерированный процесс: **-s 1 -l 3:50,3:50** или **-s 2 -l 3:50,3:50** или **-s 3 -l 3:50,3:50**. Нарисуйте таблицу выполнения процесса, статистику и ответьте на вопрос: Что случится при использовании флагов **-I IO_RUN_IMMEDIATE** в противовес флагу **-I IO_RUN_LATER**?  Что случится при использовании флагов **-S SWITCH_ON_IO** в противовес флагу **-S SWITCH_ON_END**?
