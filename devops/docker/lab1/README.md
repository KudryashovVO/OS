# Лабораторная работа №1 "Введение в Docker"

Требования к окружению для выполнению л\р:
- установленная 64-битная ОС, например debian 9
- установленный docker daemon: https://docs.docker.com/install/linux/docker-ce/debian/

Перед выполнением л\р обязательно к прочтению: https://habr.com/en/post/346634/

# Задание

## Проверка работоспособности установленного docker daemon и изучение этого контейнера

выполните команду
```bash
docker run hello-world
```

вы увидите сначала такую ошибку:
```bash
Unable to find image 'hello-world:latest' locally
```

после чего начнется скачивание образа:
```bash
latest: Pulling from library/hello-world
1b930d010525: Pull complete 
Digest: sha256:92695bc579f31df7a63da6922075d0666e565ceccad16b59c3374d2cf4e8e50e
Status: Downloaded newer image for hello-world:latest
```
docker отрапортовал что начал скачивать и успешно скачал требуемый нами образ, также указал его hash. Затем мы увидим
некоторое приветственное сообщение. Если у вас все получилось - значит все сделано правильно.

Давайте рассмотрим что же такое у нас сейчас произошло.
1) Скачался запрашиваемый нами образ. По-умолчанию, если мы не указываем никакой адрес хранилища (docker registry),
используется hub.docker.com
2) Запросим у docker информацию о скачанном образе:
```bash
docker images hello-world
```
В результате нам покажут информацию об образе - из какого репозитория взят образ, его версию, идентификатор, дату создания
и его размер. В моем случае это 1.84кб
3) Как вы уже знаете, все контейнеры состоят из слоев. Давайте взглянем на то, как именно был собран этот контейнер
Возьмем исходный код из официального 
[репозитория](https://github.com/docker-library/hello-world/blob/master/amd64/hello-world/Dockerfile)
```dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```
Необходимым и достаточным условием для сборки контейнера является директива FROM (строка 1), 
которая используется для формировании основы нашего будущего контейнера. Классическим способом является использование
уже готовых контейнеров, например, node, nginx, redis, debian, alpine, centos итп. Такие контейнеры уже содержат 
базовую файловую систему, опираясь на которую мы можем создавать свой сервис.
В данном случае задача приветственного контейнера - просто вывести некоторое сообщение.
Базовая файловая система - набор утилит, библиотек, конфигурационных и исполняемых файлов, расположенные в некоторых
каталогах и подкаталогах. Весь этот набор нужен для функционирования необходимого нам дополнительного ПО, например,
службы веб сервера, базы данных, итд итп, фактически здесь речь идет о любом софте в ОС linux. Однако, из коробки docker
поддерживает работу скомпилированных файлов на языке С. Это достигается за счет изкоробочной поддержки библиотеки libc,
и позволяет нам создавать практически невесомые контейнеры, которые будут состоять хоть из одного файла, который добавляется
командой COPY (строка 2). Наконец, мы инструктируем docker запускать наш исполняемый файл
[hello](https://github.com/docker-library/hello-world/blob/master/hello.c) при старте контейнера. Посмотрите его исходный
код - в нем вы как раз найдете все строки, которые вывелись вам при старте контейнера.
Следует понимать что старт контейнера это не какое-то абстрактное понятие - под стартом понимается именно запуск некоторой
команды (команд), исполняемого файла или скрипта, указанного пользователем. В случае использования чьих-то контейнеров
по-умолчанию строка запуска наследуется, но ее можно переопределить или как в данном случае - написать самим, поскольку
контейнера-основы не существует.

Давайте посмотрим как docker хранит образы на вашей локальной машине:
```bash
docker inspect hello-world
```
В выводе вы увидите похожие строки:
```text
"GraphDriver": {
    "Data": {
        "MergedDir": "/var/lib/docker/overlay2/e6b2f0a1bbafb09db96c5772113321e1bfc0e13b3292afe50b6c781e2f350060/merged",
        "UpperDir": "/var/lib/docker/overlay2/e6b2f0a1bbafb09db96c5772113321e1bfc0e13b3292afe50b6c781e2f350060/diff",
        "WorkDir": "/var/lib/docker/overlay2/e6b2f0a1bbafb09db96c5772113321e1bfc0e13b3292afe50b6c781e2f350060/work"
    },
    "Name": "overlay2"
},
"RootFS": {
    "Type": "layers",
    "Layers": [
        "sha256:af0b15c8625bb1938f1d7b17081031f649fd14e6b233688eea3c5483994a66a3"
    ]
}
```
docker использует свою файловую систему (а точнее одну из нескольких) overlayfs, в данном случае она записана как
overlay2. Мы можем увидеть точку хранения файлов - /var/lib/docker/overlay2/e6b...; и если мы посмотрим содержимое
поддиректории diff, мы увидим наш исполняемый файл hello.

Давайте более детально рассмотрим из чего состоит контейнер:
```bash
mkdir /tmp/hello && cd /tmp/hello && docker save hello-world -o hello.tar && \
tar xvf hello.tar 1>/dev/null && rm hello.tar && echo -e "\ncontents of container:\n" && ls
```

Изучите файлы метаданных которые "приезжают" вместе с контейнером. Укажите из какого файла берется информация о строке
запуска CMD и прочая информация, которую вы видели в `docker inspect`. Найдите как хранятся слои с данными и расположение
файла hello.

Напоследок в этом пункте давайте разберем что происходит в системе при запуске контейнера. Выполните команду:
```bash
docker run hello-world & while true; do ps aux | grep [h]ello | grep root ; done
```

Эта конструкция запускает наш контейнер, а затем в бесконечном цикле выводит список процессов, отфильтровывая их по
ключевым словам root и hello. После заспуска вы увидите такой вывод (нажмите ctrl+c для выхода из цикла):
```bash
root     25796  0.0  0.0      0     0 ?        Ds   09:51   0:00 [hello]
root     25796  0.0  0.0      0     0 ?        Ds   09:51   0:00 [hello]
root     25796  0.0  0.0      0     0 ?        Ds   09:51   0:00 [hello]
```

А если посмотреть на дерево процессов, то мы увидим такую картину:

```text
systemd(1)-+-containerd(787)-+-containerd-shim(25776)-+-runc(25784)-+-runc:[1:CHILD](25794)
                                                                    |-runc:[2:INIT](25796)-+-{runc:[2:INIT]}(25797)
                                                                    |                      `-{runc:[2:INIT]}(25800)
                                                                    |-{runc}(25786)
                                                                    `-{runc}(25792)
```
Происходит инициализация процесса

```text
systemd(1)-+-containerd(787)-+-containerd-shim(25776)-+-runc(25784)-+-exe(25801)-+-{exe}(25803)
                                                                    |            `-{exe}(25807)
                                                                    |-runc:[1:CHILD](25794)
                                                                    |-runc:[2:INIT](25796)-+-{runc:[2:INIT]}(25797)
                                                                    |                      `-{runc:[2:INIT]}(25800)
                                                                    |-{runc}(25786)
                                                                    `-{runc}(25792)
```
И наконец его исполнение:
```text
systemd(1)-+-containerd(787)-+-containerd-shim(25776)-+-hello(25796)
```

Т.е. наш исполняемый файл действительно запускался. Как вы уже знаете, docker использует методы изоляции процесса от
хостовой системы, однако, поскольку изоляция != виртуализация, запускаемый процесс видно на хостовой ОС, он просто ограничен
в своих возможностях. Поэтому все запускаемые процессы в контейнере всегда можно увидеть в списке процессов хостовой ОС,
но помните, что они находятся в другом пространстве относительно их соседей. Такое отдельное пространство искуственно
формируется средствами ядра ос linux - cgroups, linux namespaces.

